#include "libultra.h"
#include "include_asm.h"
#include "macros_defines.h"
#include "unknown_structs.h"
#include "main_functions.h"
#include "main_variables.h"


#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E530_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E5DC_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E638_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E658_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E684_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E6B8_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E714_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003E854_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F0EC_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F178_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F1C0_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F200_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F2F0_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F42C_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F608_usa);
#endif

#if VERSION_USA
#if 0
u64 __udivdi3(s32, s32, ?, s32);                    /* extern */
s32 func_8001CAD0_usa(s32, u32 *);                  /* extern */
? func_8001F6B8_usa(s32 *, ? *, s32 *);             /* extern */
? func_80021414_usa(s32, ?, ?, s32 *);              /* extern */
? func_8002CFC8_usa();                              /* extern */
void func_8003E854_usa(void *);                     /* extern */
? func_8008B21C_usa();                              /* extern */
s32 hvqm2DecodeSP1(s32, u16, void *, void *, s32, ? *, s32); /* extern */
? hvqm2InitSP1(?);                                  /* extern */
? hvqm2SetupSP1(s32, ?, s32);                       /* extern */
extern s32 B_8018EA50_usa;
extern u32 B_8018EA58_usa;
extern OSMesgQueue B_8018EA78_usa;
extern void *B_8018EA90_usa;
extern OSIoMesg B_8018EA98_usa;
extern OSMesgQueue B_8018EAB0_usa;
extern void *B_8018EAC8_usa;
extern OSMesgQueue B_8018EAD0_usa;
extern void *B_8018EAE8_usa;
extern u32 B_8018EAEC_usa;
extern s32 B_8018EAF0_usa;
extern u32 B_8018EAF4_usa;
extern u32 B_8018EB00_usa;
extern u32 B_8018EB08_usa;
extern u32 B_8018EB0C_usa;
extern OSThread B_8018EB20_usa;
extern OSThread B_80190CD0_usa;
extern OSMesgQueue B_80192E80_usa;
extern void *B_80192E98_usa;
extern OSMesgQueue B_80192EA0_usa;
extern void *B_80192EB8_usa;
extern ? B_80192F00_usa;
extern ? B_80192F04_usa;
extern ? B_80192F08_usa;
extern ? B_80192F0C_usa;
extern s32 B_80192F20_usa;
extern s32 B_80192F24_usa;
extern s32 B_80192F64_usa;
extern s32 B_80192F68_usa;
extern s32 B_80192F70_usa;
extern u32 B_80192F74_usa;
extern s32 B_80192F78_usa;
extern u32 B_80192F7C_usa;
extern s32 B_8019CF58_usa;
extern s32 B_8019CF5C_usa;
extern ? *B_8019CF60_usa;
extern s32 B_8019CF64_usa;
extern ? *B_8019CF68_usa;
extern s32 B_8019CF6C_usa;
extern ? *B_8019CF70_usa;
extern s32 B_8019CF74_usa;
extern ? *B_8019CF88_usa;
extern s32 B_8019CF90_usa;
extern s32 B_8019CF94_usa;
extern OSThread B_8019CFA0_usa;
extern ? B_801AABA0_usa;
extern s32 *B_801AB620_usa;
extern s32 *B_801AB624_usa;
extern s32 B_801C6E48_usa;
extern OSContPad B_801C7228_usa;
extern OSMesgQueue B_8021AAE0_usa;
extern OSThread B_8021AB50_usa;
extern ? D_800AF9C0_usa;
extern ? D_800AFA90_usa;
extern ? D_800B0E80_usa;
extern s32 D_803B5000;
extern s32 D_803DA800;
extern ? func_80040B1C_usa;
extern u64 hvqm2sp1DataStart[];
extern u64 hvqm2sp1TextStart[];

s32 func_8003F810_usa(s32 arg0, u32 arg1, s32 arg2) {
    s32 sp40;
    u32 sp44;
    ? *sp48;
    s32 sp4C;
    ? sp5F;
    u32 sp6C;
    s32 sp74;
    s32 sp7C;
    s32 sp84;
    s32 sp8C;
    s32 sp94;
    u32 sp9C;
    s32 spA4;
    s32 **temp_s1_3;
    s32 **var_a2;
    s32 *temp_a0_10;
    s32 *temp_a0_3;
    s32 *temp_a0_4;
    s32 *temp_a0_5;
    s32 *temp_a0_6;
    s32 *temp_a0_7;
    s32 *temp_a0_8;
    s32 *temp_a0_9;
    s32 *temp_s0_5;
    s32 *temp_s0_6;
    s32 *temp_s0_7;
    s32 *temp_s1_4;
    s32 *temp_s1_5;
    s32 *temp_v0_5;
    s32 *temp_v1_10;
    s32 *temp_v1_11;
    s32 *temp_v1_12;
    s32 *temp_v1_13;
    s32 *temp_v1_14;
    s32 *temp_v1_15;
    s32 *temp_v1_16;
    s32 *var_a0_6;
    s32 *var_t0;
    s32 *var_v1;
    s32 *var_v1_2;
    s32 *var_v1_3;
    s32 *var_v1_4;
    s32 *var_v1_5;
    s32 *var_v1_6;
    s32 temp_a2_2;
    s32 temp_s0_2;
    s32 temp_s0_4;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s2;
    s32 temp_t3_2;
    s32 temp_t3_3;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v1;
    s32 temp_v1_8;
    s32 temp_v1_9;
    s32 var_a0;
    s32 var_a0_2;
    s32 var_a0_3;
    s32 var_a0_5;
    s32 var_a1_2;
    s32 var_a1_3;
    s32 var_a1_4;
    s32 var_a3;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s0_7;
    s32 var_s0_8;
    s32 var_s4;
    s32 var_s7;
    s32 var_v0;
    u16 temp_s0_3;
    u32 temp_a0;
    u32 temp_a0_2;
    u32 temp_a1;
    u32 temp_a1_2;
    u32 temp_a1_3;
    u32 temp_a1_4;
    u32 temp_a1_5;
    u32 temp_a1_6;
    u32 temp_a2;
    u32 temp_a2_3;
    u32 temp_s0;
    u32 temp_s0_8;
    u32 temp_s2_2;
    u32 temp_s2_3;
    u32 temp_s3_3;
    u32 temp_s3_4;
    u32 temp_s5;
    u32 temp_t1;
    u32 temp_t3;
    u32 temp_v1_2;
    u32 temp_v1_3;
    u32 temp_v1_4;
    u32 temp_v1_5;
    u32 temp_v1_6;
    u32 temp_v1_7;
    u32 var_a1;
    u32 var_s0_3;
    u32 var_s0_4;
    u32 var_s1;
    u32 var_s1_2;
    u32 var_s1_3;
    u32 var_s1_4;
    u32 var_t1;
    u64 temp_ret;
    u64 temp_ret_2;
    u64 temp_ret_3;
    u64 temp_ret_4;
    u64 temp_ret_5;
    u64 temp_ret_6;
    u64 var_a0_4;
    u64 var_s0_5;
    u64 var_s0_6;
    u64 var_t0_2;
    void *temp_s3;
    void *temp_s3_2;

    sp6C = arg1;
    var_s7 = -1;
    temp_s5 = sp6C >> 0x10;
    temp_t3 = sp6C & 0xFFFF;
    sp6C = temp_t3;
    if (temp_t3 & 0x1000) {
        func_8001F6B8_usa(&sp40, "iSkip16.BIF", &arg2);
        arg2 = (arg2 + 0xF) & ~0xF;
    }
    var_v0 = func_8001CAD0_usa(arg0, &sp44);
    if (var_v0 != 0) {
        B_8018EA58_usa = sp44;
        var_s0 = 0;
        osViBlack(1U);
        func_8002CFC8_usa();
        func_80002D5C_usa();
        func_80002DE8_usa();
        do {
loop_4:
            if (osViGetCurrentLine() != 0) {
                goto loop_4;
            }
loop_5:
            if (osViGetCurrentLine() == 0) {
                goto loop_5;
            }
            var_s0 += 1;
        } while (var_s0 < 8);
        var_s0_2 = 0;
        osStopThread(&B_8021AB50_usa);
        osStopThread(&B_8019CFA0_usa);
        do {
loop_8:
            if (osViGetCurrentLine() != 0) {
                goto loop_8;
            }
loop_9:
            if (osViGetCurrentLine() == 0) {
                goto loop_9;
            }
            var_s0_2 += 1;
        } while (var_s0_2 < 8);
        func_8008B21C_usa();
        B_801AB624_usa = &D_803DA800;
        B_801AB620_usa = &D_803B5000;
        temp_v0 = (arg2 + 7) & ~7;
        B_8018EA50_usa = temp_v0;
        arg2 += 0x46290;
        if ((temp_v0 + 0x10) & 0xF) {
            osSyncPrintf("ERROR: 'pcmbuf' not 16-byte aligned!\n", 0x46290);
        }
        if ((B_8018EA50_usa + 0x11910) & 0xF) {
            osSyncPrintf("ERROR: 'hvqbuf' not 16-byte aligned!\n");
        }
        if ((B_8018EA50_usa + 0x18E50) & 0xF) {
            osSyncPrintf("ERROR: 'adpcmbuf' not 16-byte aligned!\n");
        }
        if ((B_8018EA50_usa + 0x19A10) & 0xF) {
            osSyncPrintf("ERROR: 'hvqwork' not 16-byte aligned!\n");
        }
        if ((B_8018EA50_usa + 0x1E520) & 0xF) {
            osSyncPrintf("ERROR: 'hvq_spfifo' not 16-byte aligned!\n");
        }
        if ((B_8018EA50_usa + 0x45630) & 0xF) {
            osSyncPrintf("ERROR: 'hvq_yieldbuf' not 16-byte aligned!\n");
        }
        temp_s1 = ((u32) (B_8018EA50_usa + 0x4624F) >> 4) * 0x10;
        osCreateMesgQueue(&B_8018EAD0_usa, &B_8018EAE8_usa, 1);
        osSetEventMesg(4U, &B_8018EAD0_usa, NULL);
        osCreateMesgQueue(&B_8018EA78_usa, &B_8018EA90_usa, 1);
        osCreateMesgQueue(&B_8018EAB0_usa, &B_8018EAC8_usa, 1);
        osCreateMesgQueue(&B_80192E80_usa, &B_80192E98_usa, 1);
        osCreateMesgQueue(&B_80192EA0_usa, &B_80192EB8_usa, 1);
        osCreateThread(&B_8018EB20_usa, 3, func_8003E854_usa, NULL, &B_80190CD0_usa, 0xC);
        osStartThread(&B_8018EB20_usa);
        hvqm2InitSP1(0xFF);
        var_t0 = &B_801C6E48_usa;
        var_a3 = 0;
        var_a2 = &B_801AB620_usa;
        B_8019CF6C_usa = &D_800B0E80_usa - &hvqm2sp1TextStart;
        B_8019CF70_usa = &hvqm2sp1DataStart;
        B_8019CF68_usa = &hvqm2sp1TextStart;
        B_8019CF58_usa = 7;
        B_8019CF64_usa = &D_800AFA90_usa - &D_800AF9C0_usa;
        B_8019CF74_usa = 0x70;
        B_8019CF88_usa = &B_801AABA0_usa;
        B_8019CF5C_usa = 0;
        B_8019CF60_usa = &D_800AF9C0_usa;
        B_8019CF94_usa = 0xC10;
        B_8019CF90_usa = B_8018EA50_usa + 0x45630;
        do {
            var_a0 = 0;
loop_25:
            temp_v1 = var_a0 * 2;
            var_a0 += 1;
            *(temp_v1 + *var_a2) = 0;
            if (var_a0 <= 0x12BFF) {
                goto loop_25;
            }
            *var_t0 = 0;
            var_t0 += 4;
            var_a3 += 4;
            var_a2 += 4;
        } while (var_a3 < 8);
        osViSwapBuffer(B_801AB624_usa);
        osViBlack(1U);
        temp_s0 = B_8018EA58_usa;
        osInvalDCache((void *) temp_s1, 0x3C);
        do {

        } while (osPiStartDma(&B_8018EA98_usa, 0, 0, temp_s0, (void *) temp_s1, 0x3CU, &B_8018EAB0_usa) == -1);
        osRecvMesg(&B_8018EAB0_usa, NULL, 1);
        B_8018EAEC_usa = temp_s1->unk_1C;
        sp9C = temp_s1->unk_20;
        temp_a2 = 0x140 - temp_s1->unk_14;
        B_8018EAF0_usa = temp_s1->unk_30;
        temp_a2_2 = (s32) (temp_a2 + (temp_a2 >> 0x1F)) >> 1;
        sp94 = (((s32) (0xF0 - temp_s1->unk_16) / 2) * 0x140) + temp_a2_2;
        hvqm2SetupSP1(temp_s1, 0x140, temp_a2_2);
        var_a0_2 = 0;
        var_v1 = &B_801C6E48_usa;
        do {
            var_a0_2 += 1;
            *var_v1 &= ~1;
            var_v1 += 4;
        } while (var_a0_2 < 2);
        sp7C = -1;
        sp84 = 0;
        sp8C = 0;
        sp48 = &func_80040B1C_usa;
        sp4C = temp_s1->unk_34;
        osSendMesg(&B_80192E80_usa, &sp48, 1);
        osRecvMesg(&B_80192EA0_usa, NULL, 1);
        if ((temp_s5 != 0) && (temp_s5 < (u32) B_8018EAEC_usa)) {
            B_8018EB00_usa = temp_s5;
        }
        sp74 = 0;
        if (B_8018EB00_usa != 0) {
            spA4 = 0x11910;
loop_36:
            temp_t3_2 = sp74 + 1;
            sp74 = temp_t3_2;
            if (temp_t3_2 >= 5) {
                osViBlack(0U);
            }
            osContStartReadData(&B_801AB988_usa);
            temp_s2 = ((u32) &sp5F >> 4) * 0x10;
            var_s0_3 = B_8018EAF4_usa;
            temp_s3 = B_8018EA50_usa + spA4;
loop_39:
            osInvalDCache((void *) temp_s2, 8);
            do {

            } while (osPiStartDma(&B_8018EA98_usa, 0, 0, var_s0_3, (void *) temp_s2, 8U, &B_8018EAB0_usa) == -1);
            osRecvMesg(&B_8018EAB0_usa, NULL, 1);
            temp_s1_2 = temp_s2->unk_4;
            var_s0_4 = var_s0_3 + 8;
            if (temp_s2->unk_0 != 1) {
                var_s0_3 = var_s0_4 + temp_s1_2;
                goto loop_39;
            }
            if (temp_s1_2 != 0) {
                osInvalDCache(temp_s3, temp_s1_2);
                do {

                } while (osPiStartDma(&B_8018EA98_usa, 0, 0, var_s0_4, temp_s3, (u32) temp_s1_2, &B_8018EAB0_usa) == -1);
                osRecvMesg(&B_8018EAB0_usa, NULL, 1);
                var_s0_4 += temp_s1_2;
            }
            B_8018EAF4_usa = var_s0_4;
            if ((B_8018EB08_usa != 0) || (B_8018EB0C_usa != 0)) {
                if (B_80192F64_usa == 0) {
                    var_t0_2 = 0;
                    var_t1 = 0;
                } else {
                    temp_ret = osGetTime();
                    temp_v1_2 = (u32) temp_ret;
                    temp_a1 = temp_v1_2 - B_80192F7C_usa;
                    temp_ret_2 = __udivdi3((((temp_ret - B_80192F78_usa) - (temp_v1_2 < (u32) B_80192F7C_usa)) << 6) | (temp_a1 >> 0x1A), temp_a1 << 6, 0, 0xBB8);
                    var_s0_5 = temp_ret_2;
                    var_s1 = (u32) temp_ret_2;
                    if (B_80192F68_usa != 0) {
                        temp_v1_3 = B_80192F74_usa * 0x1F;
                        temp_v0_2 = (((B_80192F70_usa << 5) | ((u32) B_80192F74_usa >> 0x1B)) - B_80192F70_usa) - ((u32) (B_80192F74_usa << 5) < (u32) B_80192F74_usa);
                        temp_a1_2 = B_80192F74_usa * 0x3D09;
                        temp_ret_3 = __udivdi3(((((((((temp_v0_2 << 6) | (temp_v1_3 >> 0x1A)) - temp_v0_2) - ((u32) (B_80192F74_usa * 0x7C0) < temp_v1_3)) * 8) | ((u32) (B_80192F74_usa * 0x7A1) >> 0x1D)) + B_80192F70_usa + (temp_a1_2 < (u32) B_80192F74_usa)) << 6) | (temp_a1_2 >> 0x1A), B_80192F74_usa * 0xF4240, 0, B_80192F68_usa);
                        temp_v1_4 = (u32) temp_ret_3;
                        var_s1 += temp_v1_4;
                        var_s0_5 = var_s0_5 + temp_ret_3 + (var_s1 < temp_v1_4);
                    }
                    var_t0_2 = var_s0_5;
                    var_t1 = var_s1;
                }
                temp_a0 = sp9C * 2;
                temp_a1_3 = B_8018EB0C_usa + temp_a0;
                temp_a0_2 = B_8018EB08_usa + (temp_a1_3 < temp_a0);
                if ((temp_a0_2 < var_t0_2) || ((var_t0_2 == temp_a0_2) && (temp_a1_3 < var_t1))) {
                    var_a0_3 = 0;
                    var_v1_2 = &B_801C6E48_usa;
                    do {
                        var_a0_3 += 1;
                        *var_v1_2 &= ~1;
                        var_v1_2 += 4;
                    } while (var_a0_3 < 2);
loop_78:
                    temp_a1_4 = B_8018EB0C_usa + sp9C;
                    temp_a2_3 = B_8018EB00_usa - 1;
                    B_8018EB08_usa += temp_a1_4 < sp9C;
                    B_8018EB0C_usa = temp_a1_4;
                    B_8018EB00_usa = temp_a2_3;
                    if (temp_a2_3 != 0) {
                        var_s1_2 = B_8018EAF4_usa;
                        temp_s3_2 = B_8018EA50_usa + spA4;
loop_61:
                        osInvalDCache((void *) temp_s2, 8);
                        do {

                        } while (osPiStartDma(&B_8018EA98_usa, 0, 0, var_s1_2, (void *) temp_s2, 8U, &B_8018EAB0_usa) == -1);
                        osRecvMesg(&B_8018EAB0_usa, NULL, 1);
                        temp_s0_2 = temp_s2->unk_4;
                        var_s1_3 = var_s1_2 + 8;
                        if (temp_s2->unk_0 != 1) {
                            var_s1_2 = var_s1_3 + temp_s0_2;
                            goto loop_61;
                        }
                        if (temp_s0_2 != 0) {
                            osInvalDCache(temp_s3_2, temp_s0_2);
                            do {

                            } while (osPiStartDma(&B_8018EA98_usa, 0, 0, var_s1_3, temp_s3_2, (u32) temp_s0_2, &B_8018EAB0_usa) == -1);
                            osRecvMesg(&B_8018EAB0_usa, NULL, 1);
                            var_s1_3 += temp_s0_2;
                        }
                        B_8018EAF4_usa = var_s1_3;
                        if (temp_s2->unk_2 == 0) {
                            if (B_80192F64_usa == 0) {
                                var_a0_4 = 0;
                                var_a1 = 0;
                            } else {
                                temp_ret_4 = osGetTime();
                                temp_v1_5 = (u32) temp_ret_4;
                                temp_a1_5 = temp_v1_5 - B_80192F7C_usa;
                                temp_ret_5 = __udivdi3((((temp_ret_4 - B_80192F78_usa) - (temp_v1_5 < (u32) B_80192F7C_usa)) << 6) | (temp_a1_5 >> 0x1A), temp_a1_5 << 6, 0, 0xBB8);
                                var_s0_6 = temp_ret_5;
                                var_s1_4 = (u32) temp_ret_5;
                                if (B_80192F68_usa != 0) {
                                    temp_v1_6 = B_80192F74_usa * 0x1F;
                                    temp_v0_3 = (((B_80192F70_usa << 5) | ((u32) B_80192F74_usa >> 0x1B)) - B_80192F70_usa) - ((u32) (B_80192F74_usa << 5) < (u32) B_80192F74_usa);
                                    temp_a1_6 = B_80192F74_usa * 0x3D09;
                                    temp_ret_6 = __udivdi3(((((((((temp_v0_3 << 6) | (temp_v1_6 >> 0x1A)) - temp_v0_3) - ((u32) (B_80192F74_usa * 0x7C0) < temp_v1_6)) * 8) | ((u32) (B_80192F74_usa * 0x7A1) >> 0x1D)) + B_80192F70_usa + (temp_a1_6 < (u32) B_80192F74_usa)) << 6) | (temp_a1_6 >> 0x1A), B_80192F74_usa * 0xF4240, 0, B_80192F68_usa);
                                    temp_v1_7 = (u32) temp_ret_6;
                                    var_s1_4 += temp_v1_7;
                                    var_s0_6 = var_s0_6 + temp_ret_6 + (var_s1_4 < temp_v1_7);
                                }
                                var_a0_4 = var_s0_6;
                                var_a1 = var_s1_4;
                            }
                            if (((u32) B_8018EB08_usa < var_a0_4) || ((var_a0_4 == B_8018EB08_usa) && ((u32) B_8018EB0C_usa < var_a1))) {
                                goto loop_78;
                            }
                        } else {
                            goto loop_78;
                        }
                    }
                    if (B_8018EB00_usa != 0) {
                        goto block_80;
                    }
                } else {
                    goto block_80;
                }
            } else {
block_80:
                temp_s0_3 = temp_s2->unk_2;
                var_a0_5 = 0;
                if ((temp_s0_3 & 0xFFFF) == 2) {
                    var_s4 = var_s7;
                } else {
loop_82:
                    var_v1_3 = &B_801C6E48_usa;
loop_83:
                    if (*var_v1_3 != 0) {
                        var_a0_5 += 1;
                        var_v1_3 += 4;
                        if (var_a0_5 >= 2) {
                            osYieldThread();
                            var_a0_5 = 0;
                            goto loop_82;
                        }
                        goto loop_83;
                    }
                    var_s4 = var_a0_5;
                    temp_s1_3 = &(&B_801AB620_usa)[var_a0_5];
                    B_8019CF5C_usa = 0;
                    temp_v0_4 = sp94 * 2;
                    temp_s0_4 = hvqm2DecodeSP1(B_8018EA50_usa + spA4, temp_s0_3, *temp_s1_3 + temp_v0_4, (&B_801AB620_usa)[var_s7] + temp_v0_4, B_8018EA50_usa + 0x19A10, &B_801AABA0_usa, B_8018EA50_usa + 0x1E520);
                    osWritebackDCacheAll();
                    if (temp_s0_4 > 0) {
                        osInvalDCache(*temp_s1_3, 0x25800);
                        temp_s0_5 = &B_8019CF5C_usa - 4;
                        osSpTaskLoad((OSTask *) temp_s0_5);
                        osSpTaskStartGo((OSTask *) temp_s0_5);
                        osRecvMesg(&B_8018EAD0_usa, NULL, 1);
                    }
                }
                if (sp6C & 0x1000) {
                    func_80021414_usa(sp40, 0xF2, 0xD0, (&B_801AB620_usa)[var_s4]);
                }
                temp_a0_3 = &(&B_801C6E48_usa)[var_s4];
                *temp_a0_3 |= 1;
                if ((((u32) ~var_s7 >> 0x1F) & (var_s7 != var_s4)) && (var_s7 >= 0)) {
                    temp_v0_5 = &(&B_801C6E48_usa)[var_s7];
                    *temp_v0_5 &= ~1;
                }
                temp_s1_4 = (&B_801AB620_usa)[var_s4];
                temp_s0_6 = &(&B_801C6E48_usa)[var_s4];
                temp_s2_2 = B_8018EB08_usa;
                temp_s3_3 = B_8018EB0C_usa;
                *temp_s0_6 |= 2;
loop_95:
                if (B_80192F20_usa >= 2) {
                    osYieldThread();
                    goto loop_95;
                }
                temp_v1_8 = B_80192F24_usa * 0x10;
                temp_v0_6 = B_80192F24_usa + 1;
                *(&B_80192F00_usa + temp_v1_8) = temp_s2_2;
                *(&B_80192F04_usa + temp_v1_8) = temp_s3_3;
                *(&B_80192F08_usa + temp_v1_8) = temp_s1_4;
                *(&B_80192F0C_usa + temp_v1_8) = temp_s0_6;
                B_80192F24_usa = temp_v0_6;
                var_s7 = var_s4;
                if (temp_v0_6 == 2) {
                    B_80192F24_usa = 0;
                }
                B_80192F20_usa += 1;
                temp_t1 = B_8018EB0C_usa + sp9C;
                B_8018EB08_usa += temp_t1 < sp9C;
                B_8018EB0C_usa = temp_t1;
                B_8018EB00_usa -= 1;
                if (osRecvMesg(&B_801AB7F0_usa, NULL, 0) == 0) {
                    do {

                    } while (osAfterPreNMI() == -1);
                    sp8C = -1;
                } else {
                    osRecvMesg(&B_801AB988_usa, NULL, 1);
                    osContGetReadData(&B_801C7228_usa);
                    temp_t3_3 = sp7C & -(B_801C7228_usa.button != 0);
                    sp7C = temp_t3_3;
                    if ((temp_t3_3 == 0) && (B_801C7228_usa.button & sp6C)) {
                        sp84 = -1;
                    } else if (B_8018EB00_usa != 0) {
                        goto loop_36;
                    }
                }
            }
        }
        if (var_s7 >= 0) {
            temp_s1_5 = (&B_801AB620_usa)[var_s7];
            temp_s0_7 = &(&B_801C6E48_usa)[var_s7];
            temp_s2_3 = B_8018EB08_usa;
            temp_s3_4 = B_8018EB0C_usa;
            *temp_s0_7 |= 2;
loop_108:
            if (B_80192F20_usa >= 2) {
                osYieldThread();
                goto loop_108;
            }
            temp_v1_9 = B_80192F24_usa * 0x10;
            temp_v0_7 = B_80192F24_usa + 1;
            *(&B_80192F00_usa + temp_v1_9) = temp_s2_3;
            *(&B_80192F04_usa + temp_v1_9) = temp_s3_4;
            *(&B_80192F08_usa + temp_v1_9) = temp_s1_5;
            *(&B_80192F0C_usa + temp_v1_9) = temp_s0_7;
            B_80192F24_usa = temp_v0_7;
            if (temp_v0_7 == 2) {
                B_80192F24_usa = 0;
            }
            B_80192F20_usa += 1;
        }
        var_s0_7 = 0;
        if (sp8C == 0) {
            do {
loop_113:
                if (osViGetCurrentLine() != 0) {
                    goto loop_113;
                }
loop_114:
                if (osViGetCurrentLine() == 0) {
                    goto loop_114;
                }
                var_s0_7 += 1;
            } while (var_s0_7 < 0x10);
        }
        temp_s0_8 = osSetIntMask(1U);
        osDestroyThread(&B_80190CD0_usa);
        osDestroyThread(&B_8018EB20_usa);
        osSetIntMask(temp_s0_8);
        if (sp8C == 0) {
            var_a0_6 = osViGetNextFramebuffer();
            var_v1_4 = &D_803B5000;
            var_a1_2 = 0x12BF;
            if (var_a0_6 == &D_803B5000) {
                var_v1_4 = &D_803DA800;
            }
            do {
                temp_a0_4 = var_a0_6 + 4;
                var_a1_2 -= 1;
                *var_v1_4 = *var_a0_6;
                temp_v1_10 = var_v1_4 + 4;
                temp_a0_5 = temp_a0_4 + 4;
                *temp_v1_10 = *temp_a0_4;
                temp_v1_11 = temp_v1_10 + 4;
                temp_a0_6 = temp_a0_5 + 4;
                *temp_v1_11 = *temp_a0_5;
                temp_v1_12 = temp_v1_11 + 4;
                temp_a0_7 = temp_a0_6 + 4;
                *temp_v1_12 = *temp_a0_6;
                temp_v1_13 = temp_v1_12 + 4;
                temp_a0_8 = temp_a0_7 + 4;
                *temp_v1_13 = *temp_a0_7;
                temp_v1_14 = temp_v1_13 + 4;
                temp_a0_9 = temp_a0_8 + 4;
                *temp_v1_14 = *temp_a0_8;
                temp_v1_15 = temp_v1_14 + 4;
                temp_a0_10 = temp_a0_9 + 4;
                *temp_v1_15 = *temp_a0_9;
                temp_v1_16 = temp_v1_15 + 4;
                var_a0_6 = temp_a0_10 + 4;
                *temp_v1_16 = *temp_a0_10;
                var_v1_4 = temp_v1_16 + 4;
            } while (var_a1_2 != -1);
            var_s0_8 = 0;
            do {
loop_122:
                if (osViGetCurrentLine() != 0) {
                    goto loop_122;
                }
loop_123:
                if (osViGetCurrentLine() == 0) {
                    goto loop_123;
                }
                var_s0_8 += 1;
            } while (var_s0_8 < 0x10);
        }
        osSetEventMesg(6U, NULL, NULL);
        osViSetEvent(&B_8021AAE0_usa, (void *)0x29A, 1U);
        osSetEventMesg(4U, &B_8021AAE0_usa, (void *)0x29B);
        osStartThread(&B_8021AAE0_usa + 0x70);
        func_80003E90_usa();
        if (sp8C != 0) {
            do {
                var_v1_5 = &D_803B5000;
                var_a1_3 = 0x95FF;
loop_127:
                *var_v1_5 = 0;
                var_a1_3 -= 1;
                var_v1_5 += 4;
                if (var_a1_3 != -1) {
                    goto loop_127;
                }
                var_v1_6 = &D_803DA800;
                var_a1_4 = 0x95FF;
loop_129:
                *var_v1_6 = 0;
                var_a1_4 -= 1;
                var_v1_6 += 4;
                if (var_a1_4 != -1) {
                    goto loop_129;
                }
            } while (sp8C != 0);
        }
        osViBlack(0U);
        var_v0 = sp84;
    }
    return var_v0;
}
#else
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_8003F810_usa);
#endif
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_800409E4_usa);
#endif

#if VERSION_USA
void func_80040A4C_usa(void) {
    B_8018EA54_usa = 0xCCCC;
}
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_80040A60_usa);
#endif

#if VERSION_USA
INCLUDE_ASM("asm/usa/nonmatchings/main/03F130_usa", func_80040B1C_usa);
#endif
